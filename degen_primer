#!/usr/bin/python

# Copyright (C) 2012 Allis Tauri <allista@gmail.com>
# 
# indicator_gddccontrol is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# indicator_gddccontrol is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.

'''
Created on Jun 19, 2012

Tool to compute degenerate primer parameters using BioPython

@author: Allis Tauri <allista@gmail.com>
'''


#imports
import sys
import subprocess 
from time import ctime
try:
    from Bio import SeqIO
    from Bio.Alphabet import IUPAC
    from Bio.Seq import Seq
    from Bio.SeqRecord import SeqRecord
except:
    print "The BioPython must be installed in your system for this script to work."
    sys.exit(1)

import TD_Functions    
from TD_Functions import calculate_Tm, source_feature, add_PCR_conditions, format_PCR_conditions
from Blast import write_blast_report, blast_short
from SecStructures import SecStructures
from StringTools import hr, wrap_text, print_exception
from DegenPrimerConfig import DegenPrimerConfig
###############################################################################    


print ''
#parse command line arguments and/or configuration file
args = DegenPrimerConfig()
args.parse_configuration()

#set job ID
job_id = args.job_id

#set concentrations
TD_Functions.C_Na   = args.Na
TD_Functions.C_Mg   = args.Mg
TD_Functions.C_dNTP = args.dNTP
TD_Functions.C_DNA  = args.DNA
TD_Functions.C_Prim = args.Primer

#save the configuration only after preliminary check
if not args.sense_primer and not args.antisense_primer:
    print 'At least one primer (sense or antisense) should be provided.'
    sys.exit(1)
else: args.save_configuration()
#-----------------------------------------------------------------------------#


#parse primers
primers = [[],[]]
if args.sense_primer:
    desc = 'sense'
    if args.sense_primer_id:
        p_id = args.sense_primer_id
    else: p_id = desc 
    primers[0] = [SeqRecord(Seq(args.sense_primer, IUPAC.ambiguous_dna), 
                               id=p_id, name=desc, description=desc), [], dict()]
if args.antisense_primer:
    desc = 'antisense'
    if args.antisense_primer_id:
        p_id = args.antisense_primer_id
    else: p_id = desc 
    primers[1] = [SeqRecord(Seq(args.antisense_primer, IUPAC.ambiguous_dna), 
                               id=p_id, name=desc, description=desc), [], dict()]
#-----------------------------------------------------------------------------#


#generate unambiguous primer sets
IUPAC_ambiguous={'R': ['A', 'G'],
                 'Y': ['C', 'T'],
                 'S': ['G', 'C'],
                 'W': ['A', 'T'],
                 'K': ['G', 'T'],
                 'M': ['A', 'C'],
                 'B': ['C', 'G', 'T'],
                 'D': ['A', 'G', 'T'],
                 'H': ['A', 'C', 'T'],
                 'V': ['A', 'C', 'G'],
                 'N': ['A', 'T', 'C', 'G']}

def generate_unambiguous(seq_rec):
    """generate a list of all possible combinations from an ambiguous sequence"""
    global IUPAC_ambiguous
    unambiguous_strings = ['']
    #generate list of sequence strings
    for letter in seq_rec.seq:
        n_sequences = len(unambiguous_strings)
        if letter in ['A', 'T', 'G', 'C']:
            for s in range(n_sequences):
                unambiguous_strings[s] += letter
        elif letter in IUPAC_ambiguous:
            replacements = IUPAC_ambiguous[letter]
            n_replacements = len(replacements) 
            unambiguous_strings *= n_replacements
            for r in range(n_replacements):
                for s in range(n_sequences):
                    unambiguous_strings[s+n_sequences*r] += replacements[r]
    #make a list of SeqRecords
    unambiguous_seq_list = list()
    if len(unambiguous_strings) < 2: return unambiguous_seq_list
    for s in range(len(unambiguous_strings)):
        un_seq = Seq(unambiguous_strings[s], IUPAC.unambiguous_dna)
        unambiguous_seq_list.append(SeqRecord(un_seq, description=seq_rec.description, 
                                              id=seq_rec.id+"_"+str(s)))
    return unambiguous_seq_list
#end def

#unambiguous primers
for primer in primers:
    if primer: primer[1] = generate_unambiguous(primer[0])
#-----------------------------------------------------------------------------#


#calculate melting temperatures for primers
for primer in primers:
    if not primer: continue
    #if original primer is not a degenerate
    if not primer[1]: 
        primer_Tm = calculate_Tm(primer[0])
        primer[2]['Tm'] = primer_Tm
        continue
    #else...
    n_primers = len(primer[1])
    mean_Tm, min_Tm, max_Tm = 0, 10000, 0 
    for p in range(n_primers):
        primer_Tm = calculate_Tm(primer[1][p])
        if primer_Tm:
            primer_Tm = primer_Tm
            mean_Tm  += primer_Tm
            if min_Tm >= primer_Tm: min_Tm = primer_Tm
            if max_Tm <  primer_Tm: max_Tm = primer_Tm
        else: n_primers -= 1
    feature = source_feature(primer[0])
    add_PCR_conditions(feature)
    feature.qualifiers['Tm_min']  = str(min_Tm)
    feature.qualifiers['Tm_max']  = str(max_Tm)
    feature.qualifiers['Tm_mean'] = str(mean_Tm/n_primers)
    primer[2]['Tm_min']  = min_Tm
    primer[2]['Tm_max']  = max_Tm
    primer[2]['Tm_mean'] = mean_Tm/n_primers
#-----------------------------------------------------------------------------#


#output to GenBank and ipcress files
def pfam_primers(pfam):
    global primers
    if not primers[pfam]: return [] 
    if not primers[pfam][1]:
        return [primers[pfam][0]]
    else: return primers[pfam][1]
#end def

def all_primers():
    return pfam_primers(0) + pfam_primers(1)

def primer_pair_id(seq_rec1, seq_rec2):
    return seq_rec1.id+'-'+seq_rec2.id

#GenBank file with primers
fmt = 'gb'
fmt_filename = job_id+'.'+fmt
print '\nWriting unambiguous primers to:\n   ',fmt_filename
primers_list = list()
for primer in primers:
    if not primer: continue
    primers_list.append(primer[0])
    primers_list += primer[1]
SeqIO.write(primers_list, fmt_filename, fmt)

#ipcress config file
#this is only available for pairs of primers
if args.sense_primer and args.antisense_primer:
    ipcr_program_filename = job_id+'.ipcr'
    ipcr_report_filename  = job_id+'-ipcr-report.txt'
    print '\nWriting ipcress program to:\n   ',ipcr_program_filename
    fwd_primers  = pfam_primers(0)
    rev_primers  = pfam_primers(1)
    ipcr_program = open(ipcr_program_filename, 'w')
    for fwd_primer in fwd_primers:
        for rev_primer in rev_primers:
            pcr_string  = primer_pair_id(fwd_primer, rev_primer)
            pcr_string += ' '+str(fwd_primer.seq)
            pcr_string += ' '+str(rev_primer.seq)
            pcr_string += ' '+str(args.min_amplicon)
            pcr_string += ' '+str(args.max_amplicon)
            pcr_string += '\n'
            ipcr_program.write(pcr_string)
    ipcr_program.close()
    if args.fasta_files:
        ipcr_cli = 'ipcress %s -m %d -s' % (ipcr_program_filename, args.max_mismatches)
        for fasta_file in args.fasta_files:
            ipcr_cli += ' "'+fasta_file+'"'
        try:
            child = subprocess.Popen(ipcr_cli,
                                     stdin=subprocess.PIPE,
                                     stdout=subprocess.PIPE,
                                     stderr=subprocess.PIPE,
                                     shell=(sys.platform!="win32"))
            ipcr_report = open(ipcr_report_filename, 'w')
            print '\nWriting ipcress report to:\n   ',ipcr_report_filename
            ipcr_report.write(child.stdout.read())
            ipcr_report.close()
        except OSError, e:
            print 'Faild to execute ipcress'
            print_exception(e)
            print 'It seems that "ipcress" executable is not found in the PATH.'
            print 'NOTE: it is provided by the "exonerate" package in debian-like distributions.'
        except Exception, e:
            print 'Faild to execute ipcress'
            print_exception(e)
#-----------------------------------------------------------------------------#


#test for primers specificity by BLAST
if args.do_blast:
    #generate Entrez query
    entrez_query = ''
    if args.organisms:
        for organism in args.organisms:
            if entrez_query: entrez_query += ' OR '
            entrez_query += organism+'[organism]'

    #if both primers are provided, do a concatenated blast search:
    #PRIMER1-NNNNNNNNNN-PRIMER2
    print '\nStarting a BLAST search. This may take awhile...' 
    blast_query = ''
    blast_results  = None
    if args.sense_primer and args.antisense_primer:
        fwd_primers = pfam_primers(0)
        rev_primers = pfam_primers(1)
        for fwd_primer in fwd_primers:
            for rev_primer in rev_primers:
                blast_query_str  = str(fwd_primer.seq)
                blast_query_str += 'N'*10 #spacer of 10 N
                blast_query_str += str(rev_primer.seq)
                blast_query += SeqRecord(Seq(blast_query_str, IUPAC.ambiguous_dna), 
                                         id=primer_pair_id(fwd_primer, rev_primer)).format('fasta')
        blast_results  = blast_short(blast_query, job_id, entrez_query) 
    else:
    #else just blast all primers in a single query 
        all_primers = all_primers()
        for primer in all_primers:
            blast_query += primer.format('fasta')
        blast_results  = blast_short(blast_query, job_id, entrez_query)
    #report results in human readable form
    blast_report_filename = job_id+'-blast_report.txt' 
    write_blast_report(blast_results, blast_report_filename, args.top_hits, args.top_hsps)
#-----------------------------------------------------------------------------#


#check for hairpins, dimers and cross-dimers
#check for self-dimers and hairpins
structures_full_report_filename  = job_id+'-full-report.txt'
structures_short_report_filename = job_id+'-short-report.txt'
print '\nWriting full report with all secondary structures to:\n   ',structures_full_report_filename
print '\nWriting short report with summary of secondary structures to:\n   ',structures_short_report_filename
full_structures_file  = open(structures_full_report_filename, 'w')
short_structures_file = open(structures_short_report_filename, 'w')
#write header
for f in (full_structures_file, short_structures_file):
    f.write(hr(' %s ' % ctime(), symbol='#'))
    f.write(wrap_text('For each degenerate primer provided, a set of unambiguous primers is generated. '
                      'For each such set the minimum, maximum and mean melting temperatures are calculated. '
                      'For each primer in each set stable self-dimers and hairpins are predicted. '
                      'For every possible combination of two unambiguous primers cross-dimers are also predicted. '
                      'If an unambiguous primer is provided, it is treated as a set with a single element.\n\n'))
    f.write(hr(' PCR conditions '))
    f.write(format_PCR_conditions()+'\n')
    f.write(hr(' melting temperatures '))
    #temperatures
    temps  = []
    
    if primers[0] and primers[1]:
        max_id = max(len(primers[0][0].id), len(primers[1][0].id))
    else: max_id = 0
    for primer in primers:
        if not primer: continue
        spacer = max_id-len(primer[0].id)
        if not primer[1]: #not degenerate
            f.write('%s:%s  %02db  %s\n' % (primer[0].id, ' '*spacer, len(primer[0].seq), str(primer[0].seq)) +\
                    '   Tm:      %.1f C\n' % primer[2]['Tm'])
            temps.append(primer[2]['Tm'])
        else:
            f.write('%s:%s  %02db  %s\n' % (primer[0].id, ' '*spacer, len(primer[0].seq), str(primer[0].seq)) +\
                    '   Tm max:  %.1f C\n' % primer[2]['Tm_max'] +\
                    '   Tm mean: %.1f C\n' % primer[2]['Tm_mean'] +\
                    '   Tm min:  %.1f C\n' % primer[2]['Tm_min'])
            temps.append(primer[2]['Tm_min'])
    #warning
    if len(temps) == 2:
        if abs(temps[0]-temps[1]) >= 5:
            f.write('\nWarning: lowest melting temperatures of sense and antisense primes \n'
                    '         differ more then by 5C\n')
    f.write('\n\n')
    f.write(hr(' stable secondary structures ', symbol='#'))
#short report thresholds
short_structures_file.write(hr(' only following structures are reported '))
short_structures_file.write("   dimers with free energy below %.2f kcal/mol are reported\n" \
                            % (args.dG_threshold   if args.dG_threshold<= 0 else 0))
short_structures_file.write("3'-dimers with free energy below %.2f kcal/mol are reported\n" \
                            % (args.dG_threshold+1 if args.dG_threshold<=-1 else 0))
short_structures_file.write("   hairpins with free energy below %.2f kcal/mol are reported\n" \
                            % (args.dG_threshold+2 if args.dG_threshold<=-2 else 0))
short_structures_file.write("3'-hairpins with free energy below %.2f kcal/mol are reported\n" \
                            % (args.dG_threshold+3 if args.dG_threshold<=-3 else 0))
short_structures_file.write('\n')
#check all self-dimers and hairpins
all_primers = all_primers()
for primer in all_primers:
    structs = SecStructures(primer, dG_threshold=args.dG_threshold)
    full_structures_file.write(str(structs))
    if structs.belowThreshold():
        short_structures_file.write(structs.formatShort())
#check ALL cross-dimers
num_primers = len(all_primers)
if num_primers > 1:
    for f in (full_structures_file, short_structures_file):
        f.write('\n'+hr(' stable cross dimers ', symbol='#'))
    for i in range(num_primers):
        for j in range(i+1,num_primers):
            structs = SecStructures(all_primers[i],all_primers[j], 
                                    dG_threshold=args.dG_threshold)
            full_structures_file.write(str(structs))
            if structs.belowThreshold():
                short_structures_file.write(structs.formatShort())
full_structures_file.close()
short_structures_file.close()
#-----------------------------------------------------------------------------#

sys.exit(0)