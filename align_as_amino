#!/usr/bin/python

# Copyright (C) 2012 Allis Tauri <allista@gmail.com>
# 
# indicator_gddccontrol is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# indicator_gddccontrol is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.

'''
Created on Jun 19, 2012

Tool to align multiple nucleotide sequences as amino-acid sequences 
using given translation table

@author: Allis Tauri <allista@gmail.com>
'''

if __name__ == '__main__':
    pass

#imports
import re
import os
import sys
import argparse
import subprocess
try:
    from Bio import SeqIO, AlignIO
    from Bio.Alphabet import IUPAC
    from Bio.Seq import Seq
    from Bio.SeqRecord import SeqRecord
    from Bio.Align.Applications import MuscleCommandline
    from Bio.Align import MultipleSeqAlignment
except:
    print "The BioPython must be installed in your system for this script to work."
    sys.exit(1)
from DegenPrimer.StringTools import print_exception


#parse command line arguments
parser = argparse.ArgumentParser(description='This is a tool to align multiple \
nucleotide sequences as amino-acid sequences using given translation table.')
parser.add_argument('sequences_file', 
                    type=str, nargs='+',
                    help='file(s) with DNA sequence data in FASTA or GenBank format')
parser.add_argument('-t --trans-table', dest='trans_table', metavar='N', 
                    required=False, type=int, default=1,
                    help='Translation table ID as defined by NCBI. It is used for \
                    sequences without predefined translation table only. It is advisable \
                    though to provide sequences in a GenBank file with translation \
                    table defined for each sequence in it.')
parser.add_argument('-f --force-table', dest='force_table', 
                    required=False, action='store_true', 
                    help='Force to use a translation table provided with -t option.')
args = parser.parse_args()


#parse sequences
print ""
sequences = dict()
for filename in args.sequences_file:
    if not os.path.isfile(filename):
        print "No such file: "+filename
        continue
    genbank_pattern = re.compile(".*(\.gb|\.gbk)$")
    fasta_pattern   = re.compile(".*(\.fa|\.fasta)$")
    if genbank_pattern.match(filename): filetype = "gb"
    elif fasta_pattern.match(filename): filetype = "fasta"
    else:
        print "Unable to guess format of "+filename
        print "The file will be ignored."
        print "*note: it is expected that GenBank files have .gb or .gbk extension \
and FASTA files have .fa or .fasta extension." 
        continue
    try:
        print "parsing " + filename + " as " + filetype
        for record in list(SeqIO.parse(filename, filetype)):
            sequences[record.id] = record
    except Exception,e:
        print 'align_as_amino.parse sequence:'
        print_exception(e)
        sys.exit(1)
    if len(sequences) < 2:
        print "You should provide at least 2 sequences to make an alignment."
        sys.exit(1)

#translate sequences
print ""
translated_sequences =  list()
for record in sequences.values():
    #set the alphabet to DNA
    try:
        record.seq.alphabet = IUPAC.ambiguous_dna
    except Exception,e:
        #provided sequences SHOULD be DNA ones
        print 'align_as_amino.translate sequence:'
        print_exception(e)
        print "Unable to set alphabet of the sequence:"
        print record
        sys.exit(1)

    #determine translation table
    transl_table = -1
    if args.force_table:
        #force a translation table
        transl_table = args.trans_table
    else:
        #see if a translation table is defined in qualifiers
        for feature in record.features:
            try:
                transl_table = int(feature.qualifiers['transl_table'][0])
                break
            except: pass
        if transl_table < 0: transl_table = args.trans_table
    
    #do a translation
    print "Translating sequence: " + record.id + " " + record.description
    print "Translation table: " + str(transl_table)
    trans_seq = record.seq.translate(table=transl_table, stop_symbol="X")
    trans_seq_rec = SeqRecord(trans_seq, id=record.id)
    trans_seq_rec.name = record.name
    trans_seq_rec.description = record.description
    translated_sequences.append(trans_seq_rec)


#align sequences
align_cli = MuscleCommandline(clwstrict=True)
child = subprocess.Popen(str(align_cli),
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE,
                         shell=(sys.platform!="win32"))
SeqIO.write(translated_sequences, child.stdin, 'fasta')
child.stdin.close()
alignment = AlignIO.read(child.stdout, "clustal")


#output amino acid alignment
out_clustalw = args.sequences_file[0].rstrip(".fagbk")+"_transl.aln"
AlignIO.write(alignment, out_clustalw, "clustal")


#revert translation
print ""
rev_sequences = list()
for record in alignment:
    print "Revert translation of aligned sequence "+record.id
    orig_seq = str(sequences[record.id].seq)
    rev_seq = ""
    l = 0
    for letter in record.seq:
        if letter == "-": rev_seq += "-"*3
        else:
            if l+3 < len(orig_seq):
                rev_seq += orig_seq[l:l+3]
            else: rev_seq += orig_seq[l:]
            l += 3
    if l < len(orig_seq): rev_seq += orig_seq[l:]
    rev_sequences.append(SeqRecord(Seq(rev_seq, IUPAC.ambiguous_dna), id=record.id))
    #check results
    if rev_seq.replace("-", "") == orig_seq:
        print "OK"
    else:
        print "Error: resulting sequence differs from the original"


#output the final alignment
out_clustalw = args.sequences_file[0].rstrip(".fagbk")+".aln"
try:
    AlignIO.write(MultipleSeqAlignment(rev_sequences), out_clustalw, "clustal")
    print "\nOutput written to "+out_clustalw
except Exception,e:
    print 'align_as_amino.output alignment:'
    print_exception(e)
    sys.exit(1)